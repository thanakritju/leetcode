
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>binary-tree: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">leetcode/lessons/binary-tree/binarytree.go (78.9%)</option>
				
				<option value="file1">leetcode/lessons/binary-tree/maxdepth.go (100.0%)</option>
				
				<option value="file2">leetcode/lessons/binary-tree/pathsum.go (100.0%)</option>
				
				<option value="file3">leetcode/lessons/binary-tree/symmetrictree.go (90.0%)</option>
				
				<option value="file4">leetcode/lessons/recursion/recursion.go (100.0%)</option>
				
				<option value="file5">leetcode/problems/1091-shortest-path-in-binary-matrix/shortestpath.go (0.0%)</option>
				
				<option value="file6">leetcode/problems/113-path-sum-ii/pathsumii.go (100.0%)</option>
				
				<option value="file7">leetcode/problems/1235-maximum-profit-in-job-scheduling/jobscheduling.go (87.5%)</option>
				
				<option value="file8">leetcode/problems/1353-maximum-number-of-events-that-can-be-attended/maxevents.go (96.9%)</option>
				
				<option value="file9">leetcode/problems/1584-min-cost-to-connect-all-points/mincostconnectpoints.go (0.0%)</option>
				
				<option value="file10">leetcode/problems/1590-make-sum-divisible-by-p/minsubarray.go (20.0%)</option>
				
				<option value="file11">leetcode/problems/207-course-schedule/courseschedule.go (100.0%)</option>
				
				<option value="file12">leetcode/problems/210-course-schedule-ii/coursescheduleii.go (100.0%)</option>
				
				<option value="file13">leetcode/problems/215-kth-largest-element-in-an-array/kthlargest.go (96.9%)</option>
				
				<option value="file14">leetcode/problems/234-palindrome-linked-list/palindrome.go (100.0%)</option>
				
				<option value="file15">leetcode/problems/240-search-a-2d-matrix-ii/search.go (100.0%)</option>
				
				<option value="file16">leetcode/problems/278-first-bad-version/firstbadversion.go (81.8%)</option>
				
				<option value="file17">leetcode/problems/279-perfect-squares/perfectsquares.go (100.0%)</option>
				
				<option value="file18">leetcode/problems/295-find-median-from-data-stream/medianfinder.go (100.0%)</option>
				
				<option value="file19">leetcode/problems/30-substring-with-concatenation-of-all-words/findsubstring.go (100.0%)</option>
				
				<option value="file20">leetcode/problems/31-next-permutation/nextpermutation.go (100.0%)</option>
				
				<option value="file21">leetcode/problems/322-coin-change/coinchange.go (100.0%)</option>
				
				<option value="file22">leetcode/problems/338-counting-bits/countingbits.go (100.0%)</option>
				
				<option value="file23">leetcode/problems/347-top-k-frequent-elements/topkfrequent.go (100.0%)</option>
				
				<option value="file24">leetcode/problems/39-combination-sum/combinationsum.go (100.0%)</option>
				
				<option value="file25">leetcode/problems/416-partition-equal-subset-sum/partitionequalsubsetsum.go (95.5%)</option>
				
				<option value="file26">leetcode/problems/43-trapping-rain-water/trappingrainwater.go (100.0%)</option>
				
				<option value="file27">leetcode/problems/437-path-sum-iii/pathsumiii.go (100.0%)</option>
				
				<option value="file28">leetcode/problems/438-find-all-anagrams-in-a-string/findanagrams.go (100.0%)</option>
				
				<option value="file29">leetcode/problems/47-permutations-ii/permuteunique.go (96.2%)</option>
				
				<option value="file30">leetcode/problems/506-relative-ranks/relativerank.go (100.0%)</option>
				
				<option value="file31">leetcode/problems/537-complex-number-multiplication/complexnumber.go (100.0%)</option>
				
				<option value="file32">leetcode/problems/567-permutation-in-string/permutationinstring.go (100.0%)</option>
				
				<option value="file33">leetcode/problems/60-permutation-sequence/getpermutation.go (96.8%)</option>
				
				<option value="file34">leetcode/problems/703-kth-largest-element-in-a-stream/kthlargest.go (97.3%)</option>
				
				<option value="file35">leetcode/problems/704-binary-search/search.go (100.0%)</option>
				
				<option value="file36">leetcode/problems/740-delete-and-earn/deleteandearn.go (100.0%)</option>
				
				<option value="file37">leetcode/problems/76-minimum-window-substring/minimumwindowsubstring.go (0.0%)</option>
				
				<option value="file38">leetcode/problems/77-combinations/combine.go (100.0%)</option>
				
				<option value="file39">leetcode/problems/785-is-graph-bipartite/isgraphbipartite.go (100.0%)</option>
				
				<option value="file40">leetcode/problems/863-all-nodes-distance-k-in-binary-tree/distancek.go (92.6%)</option>
				
				<option value="file41">leetcode/problems/997-find-the-town-judge/findthetownjudge.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package binarytree

type TreeNode struct {
        Val   int
        Left  *TreeNode
        Right *TreeNode
}

func preorderTraversal(root *TreeNode) []int <span class="cov8" title="1">{
        arr := preorderTraversalRecursive([]int{}, root)
        return arr
}</span>

func preorderTraversalRecursive(arr []int, root *TreeNode) []int <span class="cov8" title="1">{
        if root != nil </span><span class="cov8" title="1">{
                arr = append(arr, root.Val)
                arr = preorderTraversalRecursive(arr, root.Left)
                arr = preorderTraversalRecursive(arr, root.Right)
        }</span>
        <span class="cov8" title="1">return arr</span>
}

func inorderTraversal(root *TreeNode) []int <span class="cov8" title="1">{
        arr := inorderTraversalRecursive([]int{}, root)
        return arr
}</span>

func inorderTraversalRecursive(arr []int, root *TreeNode) []int <span class="cov8" title="1">{
        if root != nil </span><span class="cov8" title="1">{
                arr = inorderTraversalRecursive(arr, root.Left)
                arr = append(arr, root.Val)
                arr = inorderTraversalRecursive(arr, root.Right)
        }</span>
        <span class="cov8" title="1">return arr</span>
}

func postorderTraversal(root *TreeNode) []int <span class="cov8" title="1">{
        arr := postorderTraversalRecursive([]int{}, root)
        return arr
}</span>

func postorderTraversalRecursive(arr []int, root *TreeNode) []int <span class="cov8" title="1">{
        if root != nil </span><span class="cov8" title="1">{
                arr = postorderTraversalRecursive(arr, root.Left)
                arr = postorderTraversalRecursive(arr, root.Right)
                arr = append(arr, root.Val)
        }</span>
        <span class="cov8" title="1">return arr</span>
}

func levelOrder(root *TreeNode) [][]int <span class="cov8" title="1">{
        arr := levelOrderRecursive([][]int{}, root, 0)
        return arr
}</span>

func levelOrderRecursive(arr [][]int, root *TreeNode, depth int) [][]int <span class="cov8" title="1">{
        if root != nil </span><span class="cov8" title="1">{
                if len(arr) &lt;= depth </span><span class="cov8" title="1">{
                        arr = append(arr, []int{})
                }</span>
                <span class="cov8" title="1">arr[depth] = append(arr[depth], root.Val)
                arr = levelOrderRecursive(arr, root.Left, depth+1)
                arr = levelOrderRecursive(arr, root.Right, depth+1)</span>
        }
        <span class="cov8" title="1">return arr</span>
}

func searchBST(root *TreeNode, val int) *TreeNode <span class="cov0" title="0">{
        if root != nil </span><span class="cov0" title="0">{
                if root.Val == val </span><span class="cov0" title="0">{
                        return root
                }</span>
                <span class="cov0" title="0">if temp := searchBST(root.Left, val); temp != nil </span><span class="cov0" title="0">{
                        return temp
                }</span>
                <span class="cov0" title="0">if temp := searchBST(root.Right, val); temp != nil </span><span class="cov0" title="0">{
                        return temp
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package binarytree

func maxDepth(root *TreeNode) int <span class="cov8" title="1">{
        return maxDepthTopDown(root, 0, 1)
}</span>

func maxDepthTopDown(root *TreeNode, answer int, depth int) int <span class="cov8" title="1">{
        if root != nil </span><span class="cov8" title="1">{
                if depth &gt; answer </span><span class="cov8" title="1">{
                        answer = depth
                }</span>
                <span class="cov8" title="1">answer = maxDepthTopDown(root.Left, answer, depth+1)
                answer = maxDepthTopDown(root.Right, answer, depth+1)</span>
        }
        <span class="cov8" title="1">return answer</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package binarytree

func hasPathSum(root *TreeNode, targetSum int) bool <span class="cov8" title="1">{
        ans := false
        subSum := targetSum - root.Val

        if subSum == 0 &amp;&amp; root.Left == nil &amp;&amp; root.Right == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if root.Left != nil </span><span class="cov8" title="1">{
                ans = ans || hasPathSum(root.Left, subSum)
        }</span>
        <span class="cov8" title="1">if root.Right != nil </span><span class="cov8" title="1">{
                ans = ans || hasPathSum(root.Right, subSum)
        }</span>
        <span class="cov8" title="1">return ans</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package binarytree

func isSymmetric(root *TreeNode) bool <span class="cov8" title="1">{
        return topDown(true, root.Left, root.Right)
}</span>

func topDown(answer bool, p *TreeNode, q *TreeNode) bool <span class="cov8" title="1">{
        if p != nil &amp;&amp; q != nil </span><span class="cov8" title="1">{
                answer = answer &amp;&amp; p.Val == q.Val
                answer = answer &amp;&amp; topDown(answer, p.Left, q.Right)
                answer = answer &amp;&amp; topDown(answer, p.Right, q.Left)
        }</span>
        <span class="cov8" title="1">if p == nil &amp;&amp; q != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if p != nil &amp;&amp; q == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return answer</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package recursion

func reverseString(s []byte) <span class="cov8" title="1">{
        if len(s) == 1 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">reverseString(s[1:])
        temp := s[0]
        for index, char := range s[1:] </span><span class="cov8" title="1">{
                s[index] = char
        }</span>
        <span class="cov8" title="1">s[len(s)-1] = temp</span>
}

type ListNode struct {
        Val  int
        Next *ListNode
}

func swapPairs(head *ListNode) *ListNode <span class="cov8" title="1">{
        swapPairsHelper(head, true)
        return head
}</span>

func swapPairsHelper(head *ListNode, shouldSwap bool) <span class="cov8" title="1">{
        if head == nil || head.Next == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if shouldSwap </span><span class="cov8" title="1">{
                temp := head.Next.Val
                head.Next.Val = head.Val
                head.Val = temp
        }</span>
        <span class="cov8" title="1">swapPairsHelper(head.Next, !shouldSwap)</span>
}

func reverseList(head *ListNode) *ListNode <span class="cov8" title="1">{
        if head == nil || head.Next == nil </span><span class="cov8" title="1">{
                return head
        }</span>
        <span class="cov8" title="1">rest := reverseList(head.Next)
        head.Next.Next = head
        head.Next = nil
        return rest</span>
}

func getRow(rowIndex int) []int <span class="cov8" title="1">{
        arrs := [][]int{}
        for i := 0; i &lt; rowIndex+1; i++ </span><span class="cov8" title="1">{
                arr := []int{}
                for j := 0; j &lt;= i; j++ </span><span class="cov8" title="1">{
                        arr = append(arr, getRowHelper(i, j, arrs))
                }</span>
                <span class="cov8" title="1">arrs = append(arrs, arr)</span>
        }
        <span class="cov8" title="1">return arrs[rowIndex]</span>
}

func getRowHelper(rowIndex int, columnIndex int, memory [][]int) int <span class="cov8" title="1">{
        if columnIndex == rowIndex || columnIndex == 0 </span><span class="cov8" title="1">{
                return 1
        }</span>
        <span class="cov8" title="1">if len(memory) &gt; rowIndex &amp;&amp; len(memory[rowIndex]) &gt; 0 </span><span class="cov8" title="1">{
                return memory[rowIndex][columnIndex]
        }</span>
        <span class="cov8" title="1">return getRowHelper(rowIndex-1, columnIndex-1, memory) + getRowHelper(rowIndex-1, columnIndex, memory)</span>
}

func fib(n int) int <span class="cov8" title="1">{
        cache := make(map[int]int)
        return fibRecursive(n, cache)
}</span>

func fibRecursive(n int, cache map[int]int) int <span class="cov8" title="1">{
        i, ok := cache[n]
        var result int
        if ok </span><span class="cov8" title="1">{
                return i
        }</span>
        <span class="cov8" title="1">if n &lt; 2 </span><span class="cov8" title="1">{
                result = n
        }</span> else<span class="cov8" title="1"> {
                result = fibRecursive(n-1, cache) + fibRecursive(n-2, cache)
        }</span>
        <span class="cov8" title="1">cache[n] = result
        return result</span>
}

func climbStairs(n int) int <span class="cov8" title="1">{
        arr := []int{0, 1, 2, 3}
        for </span><span class="cov8" title="1">{
                lenArr := len(arr)
                if lenArr &gt; n </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">arr = append(arr, arr[lenArr-1]+arr[lenArr-2])</span>
        }
        <span class="cov8" title="1">return arr[n]</span>
}

func myPow(x float64, n int) float64 <span class="cov8" title="1">{
        dp := make(map[int]float64)
        return myPowRecursive(x, n, dp)
}</span>

func myPowRecursive(x float64, n int, dp map[int]float64) float64 <span class="cov8" title="1">{
        if n == 0 </span><span class="cov8" title="1">{
                return 1
        }</span>
        <span class="cov8" title="1">if n == 1 </span><span class="cov8" title="1">{
                return x
        }</span>

        <span class="cov8" title="1">v, ok := dp[n]
        if ok </span><span class="cov8" title="1">{
                return v
        }</span>

        <span class="cov8" title="1">n1 := n / 2
        n2 := n - n1
        if n &gt; 1 </span><span class="cov8" title="1">{
                result := myPowRecursive(x, n1, dp) * myPowRecursive(x, n2, dp)
                dp[n] = result
                return result
        }</span>
        <span class="cov8" title="1">result := myPowRecursive(x, -n1, dp) * myPowRecursive(x, -n2, dp)
        dp[n] = result
        return 1 / result</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package shortestpath

type Node struct {
        x int
        y int
}

func shortestPathBinaryMatrix(grid [][]int) int <span class="cov0" title="0">{
        return -1
}</span>

func getNeighbours(node []int) [][]int <span class="cov0" title="0">{
        neighbours := [][]int{}
        for i := range []int{-1, 0, 1} </span><span class="cov0" title="0">{
                for j := range []int{-1, 0, 1} </span><span class="cov0" title="0">{
                        if i != j </span><span class="cov0" title="0">{
                                neighbours = append(neighbours, []int{node[0] + i, node[1] + j})
                        }</span>
                }
        }
        <span class="cov0" title="0">return neighbours</span>
}

func enqueue(queue [][]int, element []int) [][]int <span class="cov0" title="0">{
        return append(queue, element)
}</span>

func dequeue(queue [][]int) ([]int, [][]int) <span class="cov0" title="0">{
        return queue[0], queue[1:]
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package pathsumii

type TreeNode struct {
        Val   int
        Left  *TreeNode
        Right *TreeNode
}

func pathSum(root *TreeNode, targetSum int) [][]int <span class="cov8" title="1">{
        return getAllArrays(root, [][]int{}, []int{}, targetSum)
}</span>

func getAllArrays(root *TreeNode, arrays [][]int, array []int, targetSum int) [][]int <span class="cov8" title="1">{
        if root != nil </span><span class="cov8" title="1">{
                array = append(array, root.Val)
                if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp; sumArray(array) == targetSum </span><span class="cov8" title="1">{
                        copiedArray := make([]int, len(array))
                        copy(copiedArray, array)
                        arrays = append(arrays, copiedArray)
                }</span> else<span class="cov8" title="1"> {
                        arrays = getAllArrays(root.Left, arrays, array, targetSum)
                        arrays = getAllArrays(root.Right, arrays, array, targetSum)
                }</span>
        }
        <span class="cov8" title="1">return arrays</span>
}

func sumArray(array []int) int <span class="cov8" title="1">{
        sum := 0
        for _, each := range array </span><span class="cov8" title="1">{
                sum += each
        }</span>
        <span class="cov8" title="1">return sum</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package maximumprofitinjobscheduling

import "sort"

type Job struct {
        startTime int
        endTime   int
        profit    int
}
type Jobs []Job

func (j Jobs) Len() int <span class="cov8" title="1">{ return len(j) }</span>
func (j Jobs) Less(x, y int) bool <span class="cov8" title="1">{
        return j[x].startTime &lt; j[y].startTime
}</span>
func (j Jobs) Swap(x, y int) <span class="cov0" title="0">{ j[x], j[y] = j[y], j[x] }</span>

func jobScheduling(startTime []int, endTime []int, profit []int) int <span class="cov8" title="1">{
        var jobs Jobs
        for i := 0; i &lt; len(startTime); i++ </span><span class="cov8" title="1">{
                jobs = append(jobs, Job{startTime: startTime[i], endTime: endTime[i], profit: profit[i]})
        }</span>
        <span class="cov8" title="1">sort.Sort(jobs)
        return len(jobs)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package maxevents

import (
        "container/heap"
)

type event [][]int
type minHeap [][]int

func maxEvents(events [][]int) int <span class="cov8" title="1">{
        allevents := event(events)
        attendables := minHeap([][]int{})
        heap.Init(&amp;attendables)
        heap.Init(&amp;allevents)
        joined := 0
        for day := 1; day &lt;= 100000; day++ </span><span class="cov8" title="1">{
                for len(allevents) &gt; 0 &amp;&amp; allevents[0][0] &lt;= day </span><span class="cov8" title="1">{
                        heap.Push(&amp;attendables, heap.Pop(&amp;allevents))
                }</span>

                <span class="cov8" title="1">for len(attendables) &gt; 0 &amp;&amp; attendables[0][1] &lt; day </span><span class="cov8" title="1">{
                        heap.Pop(&amp;attendables)
                }</span>

                <span class="cov8" title="1">if len(attendables) &gt; 0 </span><span class="cov8" title="1">{
                        heap.Pop(&amp;attendables)
                        joined += 1
                }</span>
        }
        <span class="cov8" title="1">return joined</span>
}

func (e event) Len() int <span class="cov8" title="1">{ return len(e) }</span>
func (e event) Less(i, j int) bool <span class="cov8" title="1">{
        return e[i][0] &lt; e[j][0]
}</span>
func (e event) Swap(i, j int) <span class="cov8" title="1">{ e[i], e[j] = e[j], e[i] }</span>
func (e *event) Push(x interface{}) <span class="cov0" title="0">{
        *e = append(*e, x.([]int))
}</span>
func (e *event) Pop() interface{} <span class="cov8" title="1">{
        old := *e
        n := len(old)
        x := old[n-1]
        *e = old[0 : n-1]
        return x
}</span>

func (h minHeap) Len() int           <span class="cov8" title="1">{ return len(h) }</span>
func (h minHeap) Less(i, j int) bool <span class="cov8" title="1">{ return h[i][1] &lt; h[j][1] }</span>
func (h minHeap) Swap(i, j int)      <span class="cov8" title="1">{ h[i], h[j] = h[j], h[i] }</span>
func (h *minHeap) Push(x interface{}) <span class="cov8" title="1">{
        *h = append(*h, x.([]int))
}</span>
func (h *minHeap) Pop() interface{} <span class="cov8" title="1">{
        old := *h
        n := len(old)
        x := old[n-1]
        *h = old[0 : n-1]
        return x
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package mincosttoconnectallpoints

import "math"

func minCostConnectPoints(points [][]int) int <span class="cov0" title="0">{
        return 0
}</span>

func distance(x1 int, y1 int, x2 int, y2 int) int <span class="cov0" title="0">{
        return int(math.Abs(float64(x1-x2)) + math.Abs(float64(y1-y2)))
}</span>

type graph struct {
        edges map[int][]edge
}

type edge struct {
        nodeID int
        weight int
        next   int
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package minsubarray

func minSubarray(nums []int, p int) int <span class="cov8" title="1">{
        return 0
}</span>

func divide(nums []int, p int) bool <span class="cov0" title="0">{
        sum := 0
        for _, num := range nums </span><span class="cov0" title="0">{
                sum += num
        }</span>
        <span class="cov0" title="0">return sum%p == 0</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package courseschedule

func canFinish(numCourses int, prerequisites [][]int) bool <span class="cov8" title="1">{
        prerequisitesSet := transformEdgesToSet(prerequisites)
        visited := map[int]bool{}
        for i := 0; i &lt; numCourses; i++ </span><span class="cov8" title="1">{
                _, isVisited := visited[i]
                if isVisited </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if !dfs(i, prerequisitesSet, visited) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func dfs(v int, edges map[int][]int, visited map[int]bool) bool <span class="cov8" title="1">{
        result := true
        visited[v] = true
        nextVertices := edges[v]
        if len(nextVertices) != 0 </span><span class="cov8" title="1">{
                for _, nextV := range nextVertices </span><span class="cov8" title="1">{
                        onStack, isVisited := visited[nextV]

                        if !isVisited </span><span class="cov8" title="1">{
                                result = result &amp;&amp; dfs(nextV, edges, visited)
                        }</span> else<span class="cov8" title="1"> if onStack </span><span class="cov8" title="1">{
                                result = result &amp;&amp; false
                        }</span>
                }
        }
        <span class="cov8" title="1">visited[v] = false
        return result</span>
}

func transformEdgesToSet(edges [][]int) map[int][]int <span class="cov8" title="1">{
        set := map[int][]int{}
        for _, edge := range edges </span><span class="cov8" title="1">{
                adjs, ok := set[edge[1]]
                if ok </span><span class="cov8" title="1">{
                        set[edge[1]] = append(adjs, edge[0])
                }</span> else<span class="cov8" title="1"> {
                        set[edge[1]] = []int{edge[0]}
                }</span>
        }
        <span class="cov8" title="1">return set</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package coursescheduleii

var adjMatrix [2000][2000]int
var sortedList []int
var foundCyclic bool

const (
        NOT_VISITED = iota
        TEMPORARY
        PERMANENT
)

func findOrder(numCourses int, prerequisites [][]int) []int <span class="cov8" title="1">{
        adjMatrix = [2000][2000]int{}
        for _, v := range prerequisites </span><span class="cov8" title="1">{
                adjMatrix[v[1]][v[0]] = 1
        }</span>
        <span class="cov8" title="1">visited := make(map[int]int)
        sortedList = []int{}
        foundCyclic = false

        for i := 0; i &lt; numCourses; i++ </span><span class="cov8" title="1">{
                _, v := visited[i]
                if v </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if !foundCyclic </span><span class="cov8" title="1">{
                        visit(i, numCourses, visited)
                }</span>
        }

        <span class="cov8" title="1">if foundCyclic </span><span class="cov8" title="1">{
                return []int{}
        }</span> else<span class="cov8" title="1"> {
                return sortedList
        }</span>
}

func visit(n int, numCourses int, visited map[int]int) <span class="cov8" title="1">{
        v := visited[n]
        if v == PERMANENT </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if v == TEMPORARY </span><span class="cov8" title="1">{
                foundCyclic = true
                return
        }</span>
        <span class="cov8" title="1">visited[n] = TEMPORARY

        for i := 0; i &lt; numCourses; i++ </span><span class="cov8" title="1">{
                if adjMatrix[n][i] == 1 </span><span class="cov8" title="1">{
                        visit(i, numCourses, visited)
                }</span>
        }

        <span class="cov8" title="1">visited[n] = PERMANENT
        sortedList = append([]int{n}, sortedList...)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package kthlargestelementinanarray

import (
        "container/heap"
        "sort"
)

func findKthLargest(nums []int, k int) int <span class="cov8" title="1">{
        return quickSelect(&amp;nums, 0, len(nums)-1, len(nums)-k+1)
}</span>

func findKthLargest2(nums []int, k int) int <span class="cov8" title="1">{
        sort.Ints(nums)
        return nums[len(nums)-k]
}</span>

func quickSelect(nums *[]int, left, right, k int) int <span class="cov8" title="1">{
        if k &gt; 0 &amp;&amp; k &lt;= right-left+1 </span><span class="cov8" title="1">{
                index := partition(nums, left, right)

                if index-left == k-1 </span><span class="cov8" title="1">{
                        return (*nums)[index]
                }</span>

                <span class="cov8" title="1">if index-left &gt; k-1 </span><span class="cov8" title="1">{
                        return quickSelect(nums, left, index-1, k)
                }</span>

                <span class="cov8" title="1">return quickSelect(nums, index+1, right, k-index+left-1)</span>
        }
        <span class="cov0" title="0">return -1</span>
}

func partition(nums *[]int, left, right int) int <span class="cov8" title="1">{
        num := (*nums)[right]
        i := left
        for j := left; j &lt; right; j++ </span><span class="cov8" title="1">{
                if (*nums)[j] &lt;= num </span><span class="cov8" title="1">{
                        (*nums)[i], (*nums)[j] = (*nums)[j], (*nums)[i]
                        i += 1
                }</span>
        }
        <span class="cov8" title="1">(*nums)[i], (*nums)[right] = (*nums)[right], (*nums)[i]
        return i</span>
}

type pq []int

func (p pq) Len() int <span class="cov8" title="1">{
        return len(p)
}</span>

func (p pq) Less(i, j int) bool <span class="cov8" title="1">{
        return p[i] &lt; p[j]
}</span>

func (p pq) Swap(i, j int) <span class="cov8" title="1">{
        p[i], p[j] = p[j], p[i]
}</span>

func (p *pq) Pop() interface{} <span class="cov8" title="1">{
        temp := (*p)[len(*p)-1]
        *p = (*p)[:len(*p)-1]
        return temp
}</span>

func (p *pq) Push(x interface{}) <span class="cov8" title="1">{
        *p = append(*p, x.(int))
}</span>

func findKthLargest3(nums []int, k int) int <span class="cov8" title="1">{
        res := &amp;pq{}
        for _, num := range nums </span><span class="cov8" title="1">{
                heap.Push(res, num)
                if res.Len() &gt; k </span><span class="cov8" title="1">{
                        heap.Pop(res)
                }</span>
        }
        <span class="cov8" title="1">return heap.Pop(res).(int)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package palindromelinkedlist

type ListNode struct {
        Val  int
        Next *ListNode
}

func isPalindrome(head *ListNode) bool <span class="cov8" title="1">{
        arr := []int{}
        for head != nil </span><span class="cov8" title="1">{
                arr = append(arr, head.Val)
                head = head.Next
        }</span>

        <span class="cov8" title="1">return isPalindromeArray(arr)</span>
}

func isPalindromeArray(arr []int) bool <span class="cov8" title="1">{
        n := len(arr)
        for index := 0; index &lt; n/2; index++ </span><span class="cov8" title="1">{
                if arr[index] != arr[n-1-index] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package searchmatrix

func searchMatrix(matrix [][]int, target int) bool <span class="cov8" title="1">{
        for _, arr := range matrix </span><span class="cov8" title="1">{
                if binarySearch(arr, target) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func binarySearch(arr []int, target int) bool <span class="cov8" title="1">{
        min := 0
        max := len(arr)

        for min &lt; max </span><span class="cov8" title="1">{
                mid := (min + max) / 2
                if target == arr[mid] </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">if target &gt; arr[mid] </span><span class="cov8" title="1">{
                        min = mid + 1
                }</span>
                <span class="cov8" title="1">if target &lt; arr[mid] </span><span class="cov8" title="1">{
                        max = mid
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package firstbadversion

func firstBadVersion(n int) int <span class="cov8" title="1">{
        l := 0
        r := n - 1
        for l &lt; r </span><span class="cov8" title="1">{
                m := (l + r) / 2
                if isBadVersion(m) </span><span class="cov8" title="1">{
                        if !isBadVersion(m - 1) </span><span class="cov8" title="1">{
                                return m + 1
                        }</span> else<span class="cov0" title="0"> {
                                r = m - 1
                        }</span>
                } else<span class="cov8" title="1"> {
                        l = m + 1
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

func isBadVersion(version int) bool <span class="cov8" title="1">{
        return []bool{false, false, false, true, true}[version]
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package perfectsquares

func numSquares(n int) int <span class="cov8" title="1">{
        dp := make([]int, n+1)
        for i := 1; i &lt;= n; i++ </span><span class="cov8" title="1">{
                dp[i] = n + 1
        }</span>

        <span class="cov8" title="1">for target := 1; target*target &lt;= n; target++ </span><span class="cov8" title="1">{
                for s := target * target; s &lt;= n; s++ </span><span class="cov8" title="1">{
                        dp[s] = min(dp[s], 1+dp[s-target*target])
                }</span>
        }
        <span class="cov8" title="1">return dp[n]</span>
}

func min(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov8" title="1">return a</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package findmedianfromdatastream

import (
        "container/heap"
)

type MedianFinder struct {
        MaxHeap MaxHeap
        MinHeap MinHeap
}

type MinHeap []int
type MaxHeap []int

func (h MinHeap) Len() int           <span class="cov8" title="1">{ return len(h) }</span>
func (h MaxHeap) Len() int           <span class="cov8" title="1">{ return len(h) }</span>
func (h MinHeap) Less(i, j int) bool <span class="cov8" title="1">{ return h[i] &lt; h[j] }</span>
func (h MaxHeap) Less(i, j int) bool <span class="cov8" title="1">{ return h[i] &gt; h[j] }</span>
func (h MinHeap) Swap(i, j int)      <span class="cov8" title="1">{ h[i], h[j] = h[j], h[i] }</span>
func (h MaxHeap) Swap(i, j int)      <span class="cov8" title="1">{ h[i], h[j] = h[j], h[i] }</span>

func (h *MinHeap) Push(x interface{}) <span class="cov8" title="1">{
        *h = append(*h, x.(int))
}</span>
func (h *MaxHeap) Push(x interface{}) <span class="cov8" title="1">{
        *h = append(*h, x.(int))
}</span>

func (h *MinHeap) Pop() interface{} <span class="cov8" title="1">{
        old := *h
        n := len(old)
        x := old[n-1]
        *h = old[0 : n-1]
        return x
}</span>
func (h *MaxHeap) Pop() interface{} <span class="cov8" title="1">{
        old := *h
        n := len(old)
        x := old[n-1]
        *h = old[0 : n-1]
        return x
}</span>

func Constructor() MedianFinder <span class="cov8" title="1">{
        min := &amp;MinHeap{}
        max := &amp;MaxHeap{}
        heap.Init(min)
        heap.Init(max)
        return MedianFinder{MinHeap: *min, MaxHeap: *max}
}</span>

func (m *MedianFinder) AddNum(num int) <span class="cov8" title="1">{
        if float64(num) &gt; m.FindMedian() </span><span class="cov8" title="1">{
                heap.Push(&amp;m.MinHeap, num)
        }</span> else<span class="cov8" title="1"> {
                heap.Push(&amp;m.MaxHeap, num)
        }</span>
        <span class="cov8" title="1">maxHeapLen := m.MaxHeap.Len()
        minHeapLen := m.MinHeap.Len()
        if maxHeapLen-minHeapLen &gt; 1 </span><span class="cov8" title="1">{
                heap.Push(&amp;m.MinHeap, heap.Pop(&amp;m.MaxHeap))
        }</span>
        <span class="cov8" title="1">if minHeapLen-maxHeapLen &gt; 1 </span><span class="cov8" title="1">{
                heap.Push(&amp;m.MaxHeap, heap.Pop(&amp;m.MinHeap))
        }</span>
}

func (m *MedianFinder) FindMedian() float64 <span class="cov8" title="1">{
        maxHeapLen := m.MaxHeap.Len()
        minHeapLen := m.MinHeap.Len()
        if maxHeapLen == 0 &amp;&amp; minHeapLen == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if maxHeapLen &gt; minHeapLen </span><span class="cov8" title="1">{
                return float64(m.MaxHeap[0])
        }</span>
        <span class="cov8" title="1">if maxHeapLen &lt; minHeapLen </span><span class="cov8" title="1">{
                return float64(m.MinHeap[0])
        }</span>
        <span class="cov8" title="1">return float64(m.MaxHeap[0]+m.MinHeap[0]) / float64(2)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package findsubstring

func findSubstring(s string, words []string) []int <span class="cov8" title="1">{
        ans := []int{}
        word_size := len(words[0])
        word_count := len(words)
        size_l := word_size * word_count

        hash := make(map[string]int)
        for _, v := range words </span><span class="cov8" title="1">{
                _, ok := hash[v]
                if ok </span><span class="cov8" title="1">{
                        hash[v] = hash[v] + 1
                }</span> else<span class="cov8" title="1"> {
                        hash[v] = 1
                }</span>
        }

        <span class="cov8" title="1">for i := 0; i &lt; len(s) - size_l + 1; i++ </span><span class="cov8" title="1">{
                temp_hash := make(map[string]int)
                for k, v := range hash </span><span class="cov8" title="1">{
                        temp_hash[k] = v
                }</span>
                <span class="cov8" title="1">j := i
                count := word_count
                for j &lt; i + size_l </span><span class="cov8" title="1">{
                        word := s[j:j+word_size]

                        _, ok := hash[word]
                        if !ok || temp_hash[word] == 0 </span><span class="cov8" title="1">{
                                break</span>
                        } else<span class="cov8" title="1"> {
                                temp_hash[word] = temp_hash[word] -1
                                count -= 1
                        }</span>

                        <span class="cov8" title="1">j += word_size</span>
                }
                <span class="cov8" title="1">if count == 0 </span><span class="cov8" title="1">{
                        ans = append(ans, i)
                }</span>
        }

        <span class="cov8" title="1">return ans</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package nextpermutation

func nextPermutation(nums []int) <span class="cov8" title="1">{
        n := len(nums)
        k := -1
        for x := 0; x &lt; n-1; x++ </span><span class="cov8" title="1">{
                if nums[x] &lt; nums[x+1] </span><span class="cov8" title="1">{
                        if x &gt; k </span><span class="cov8" title="1">{
                                k = x
                        }</span>
                }
        }
        <span class="cov8" title="1">if k &gt; -1 </span><span class="cov8" title="1">{
                i := -1
                for x := 0; x &lt; n; x++ </span><span class="cov8" title="1">{
                        if nums[k] &lt; nums[x] </span><span class="cov8" title="1">{
                                if x &gt; i </span><span class="cov8" title="1">{
                                        i = x
                                }</span>
                        }
                }
                <span class="cov8" title="1">swap(nums, k, i)
                reverse(nums[k+1:])</span>
        } else<span class="cov8" title="1"> {
                reverse(nums)
        }</span>
}

func reverse(nums []int) <span class="cov8" title="1">{
        n := len(nums)
        for x := 0; x &lt; n/2; x++ </span><span class="cov8" title="1">{
                swap(nums, x, n-x-1)
        }</span>
}

func swap(nums []int, i, j int) <span class="cov8" title="1">{
        temp := nums[i]
        nums[i] = nums[j]
        nums[j] = temp
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package coinchange

import (
        "math"
        "sort"
)

func coinChange(coins []int, amount int) int <span class="cov8" title="1">{
        dp := make([]int, amount+1)
        sort.Ints(coins)
        for i := 1; i &lt;= amount; i++ </span><span class="cov8" title="1">{
                dp[i] = math.MaxInt32
                for _, c := range coins </span><span class="cov8" title="1">{
                        if i-c &lt; 0 </span><span class="cov8" title="1">{
                                break</span>
                        }

                        <span class="cov8" title="1">if dp[i-c] != math.MaxInt32 </span><span class="cov8" title="1">{
                                dp[i] = min(dp[i], 1+dp[i-c])
                        }</span>
                }
        }

        <span class="cov8" title="1">if dp[amount] == math.MaxInt32 </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">return dp[amount]</span>
}

func min(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov8" title="1">return a</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package countingbits

func countBits(n int) []int <span class="cov8" title="1">{
        ans := []int{0}
        index := 1
        for index &lt;= n </span><span class="cov8" title="1">{
                ans = append(ans, getNumberOfOnes(index))
                index++
        }</span>
        <span class="cov8" title="1">return ans</span>
}

func getNumberOfOnes(n int) int <span class="cov8" title="1">{
        count := 0
        for n != 0 </span><span class="cov8" title="1">{
                count += n % 2
                n = n / 2
        }</span>
        <span class="cov8" title="1">return count</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package topkfrequentelements

import "container/heap"

type item struct {
        val  int
        size int
}

type pq []item

func (p pq) Len() int <span class="cov8" title="1">{
        return len(p)
}</span>

func (p pq) Less(i, j int) bool <span class="cov8" title="1">{
        return p[i].size &gt; p[j].size
}</span>

func (p pq) Swap(i, j int) <span class="cov8" title="1">{
        p[i], p[j] = p[j], p[i]
}</span>

func (p *pq) Pop() interface{} <span class="cov8" title="1">{
        temp := (*p)[len(*p)-1]
        *p = (*p)[:len(*p)-1]
        return temp
}</span>

func (p *pq) Push(x interface{}) <span class="cov8" title="1">{
        *p = append(*p, x.(item))
}</span>

func topKFrequent(nums []int, k int) []int <span class="cov8" title="1">{
        m := make(map[int]int)
        res := &amp;pq{}
        for _, num := range nums </span><span class="cov8" title="1">{
                _, ok := m[num]
                if ok </span><span class="cov8" title="1">{
                        m[num] += 1
                }</span> else<span class="cov8" title="1"> {
                        m[num] = 1
                }</span>
        }

        <span class="cov8" title="1">for key, value := range m </span><span class="cov8" title="1">{
                heap.Push(res, item{val: key, size: value})
        }</span>

        <span class="cov8" title="1">answer := []int{}
        for i := 0; i &lt; k; i++ </span><span class="cov8" title="1">{
                answer = append(answer, heap.Pop(res).(item).val)
        }</span>
        <span class="cov8" title="1">return answer</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package combinationsum

import (
        "sort"
)

func combinationSum(candidates []int, target int) [][]int <span class="cov8" title="1">{
        sort.Ints(candidates)
        return findSolutions([]int{}, candidates, target, [][]int{})
}</span>

func findSolutions(current, candidates []int, target int, ans [][]int) [][]int <span class="cov8" title="1">{
        for _, each := range candidates </span><span class="cov8" title="1">{
                sum := sum(current) + each
                if sum &lt; target </span><span class="cov8" title="1">{
                        ans = findSolutions(append(current, each), candidates, target, ans)
                }</span>
                <span class="cov8" title="1">if sum == target </span><span class="cov8" title="1">{
                        ans = merge(ans, append(current, each))
                }</span>
        }
        <span class="cov8" title="1">return ans</span>
}

func sum(array []int) int <span class="cov8" title="1">{
        result := 0
        for _, v := range array </span><span class="cov8" title="1">{
                result += v
        }</span>
        <span class="cov8" title="1">return result</span>
}

func merge(ans [][]int, current []int) [][]int <span class="cov8" title="1">{
        for _, each := range ans </span><span class="cov8" title="1">{
                if arePermutation(each, current) </span><span class="cov8" title="1">{
                        return ans
                }</span>
        }
        <span class="cov8" title="1">tmp := make([]int, len(current))
        copy(tmp, current)
        return append(ans, tmp)</span>
}

func arePermutation(a, b []int) bool <span class="cov8" title="1">{
        if len(a) != len(b) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">var table [200]int
        for i := 0; i &lt; len(a); i++ </span><span class="cov8" title="1">{
                table[a[i]]++
                table[b[i]]--
        }</span>
        <span class="cov8" title="1">for _, value := range table </span><span class="cov8" title="1">{
                if value != 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package partitionequalsubsetsum

func canPartition(nums []int) bool <span class="cov8" title="1">{
        sum := sum(nums)
        if sum%2 != 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">targetSum := sum / 2
        dp := map[DpKey]bool{}
        return search(dp, nums, 0, targetSum)</span>
}

type DpKey struct {
        targetSum int
        depth     int
}

func search(dp map[DpKey]bool, nums []int, depth int, targetSum int) bool <span class="cov8" title="1">{
        if depth &gt;= len(nums) </span><span class="cov8" title="1">{
                return 0 == targetSum
        }</span>
        <span class="cov8" title="1">key := DpKey{targetSum: targetSum, depth: depth}
        i, ok := dp[key]
        if ok </span><span class="cov0" title="0">{
                return i
        }</span>
        <span class="cov8" title="1">result1 := false
        if nums[depth] &lt;= targetSum </span><span class="cov8" title="1">{
                result1 = search(dp, nums, depth+1, targetSum-nums[depth])
        }</span>
        <span class="cov8" title="1">result2 := search(dp, nums, depth+1, targetSum)
        dp[key] = result1 || result2
        return dp[key]</span>
}

func sum(array []int) int <span class="cov8" title="1">{
        result := 0
        for _, v := range array </span><span class="cov8" title="1">{
                result += v
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package trappingrainwater

func trap(height []int) int <span class="cov8" title="1">{
        count := 0
        foundStartEdge := false
        startEdgeIndex := 0
        endEdgeIndex := 0

        index := 0
        for true </span><span class="cov8" title="1">{
                if !foundStartEdge </span><span class="cov8" title="1">{
                        if isLocalMaxima(index, height) </span><span class="cov8" title="1">{
                                startEdgeIndex = index
                                foundStartEdge = true
                        }</span> else<span class="cov8" title="1"> {
                                index++
                        }</span>
                } else<span class="cov8" title="1"> {
                        endEdgeIndex = findEndEdge(startEdgeIndex, height)
                        if endEdgeIndex == 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">count += getWaterBetweenIndexes(startEdgeIndex, endEdgeIndex, height)
                        startEdgeIndex = endEdgeIndex</span>
                }
        }

        <span class="cov8" title="1">return count</span>
}

func findEndEdge(startIndex int, height []int) int <span class="cov8" title="1">{
        foundLocalMinima := false
        maxHeightIndex := 0
        maxHeight := 0
        for i := startIndex; i &lt; len(height); i++ </span><span class="cov8" title="1">{
                if !foundLocalMinima </span><span class="cov8" title="1">{
                        if isLocalMinima(i, height) </span><span class="cov8" title="1">{
                                foundLocalMinima = true
                        }</span>
                } else<span class="cov8" title="1"> {
                        if isLocalMaxima(i, height) </span><span class="cov8" title="1">{
                                if height[i] &gt;= height[startIndex] </span><span class="cov8" title="1">{
                                        return i
                                }</span> else<span class="cov8" title="1"> if height[i] &gt;= maxHeight </span><span class="cov8" title="1">{
                                        maxHeightIndex = i
                                        maxHeight = height[i]
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return maxHeightIndex</span>
}

func isLocalMaxima(index int, height []int) bool <span class="cov8" title="1">{
        foundLeft := false
        if index == 0 </span><span class="cov8" title="1">{
                foundLeft = true
        }</span>
        <span class="cov8" title="1">foundRight := false
        if index == len(height)-1 </span><span class="cov8" title="1">{
                foundRight = true
        }</span>
        <span class="cov8" title="1">bufferLeft := 1
        for !foundLeft &amp;&amp; index-bufferLeft &gt;= 0 </span><span class="cov8" title="1">{
                if height[index-bufferLeft] == height[index] </span><span class="cov8" title="1">{
                        bufferLeft++
                }</span> else<span class="cov8" title="1"> {
                        foundLeft = true
                        if height[index-bufferLeft] &gt; height[index] </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">bufferRight := 1
        for !foundRight &amp;&amp; index+bufferRight &lt; len(height) </span><span class="cov8" title="1">{
                if height[index] == height[index+bufferRight] </span><span class="cov8" title="1">{
                        bufferRight++
                }</span> else<span class="cov8" title="1"> {
                        foundRight = true
                        if height[index] &lt; height[index+bufferRight] </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

func isLocalMinima(index int, height []int) bool <span class="cov8" title="1">{
        foundLeft := false
        if index == 0 </span><span class="cov8" title="1">{
                foundLeft = true
        }</span>
        <span class="cov8" title="1">foundRight := false
        if index == len(height)-1 </span><span class="cov8" title="1">{
                foundRight = true
        }</span>
        <span class="cov8" title="1">bufferLeft := 1
        for !foundLeft &amp;&amp; index-bufferLeft &gt;= 0 </span><span class="cov8" title="1">{
                if height[index-bufferLeft] == height[index] </span><span class="cov8" title="1">{
                        bufferLeft++
                }</span> else<span class="cov8" title="1"> {
                        foundLeft = true
                        if height[index-bufferLeft] &lt; height[index] </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">bufferRight := 1
        for !foundRight &amp;&amp; index+bufferRight &lt; len(height) </span><span class="cov8" title="1">{
                if height[index] == height[index+bufferRight] </span><span class="cov8" title="1">{
                        bufferRight++
                }</span> else<span class="cov8" title="1"> {
                        foundRight = true
                        if height[index] &gt; height[index+bufferRight] </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

func getWaterBetweenIndexes(index1 int, index2 int, height []int) int <span class="cov8" title="1">{
        var maxHeight int
        if height[index1] &gt; height[index2] </span><span class="cov8" title="1">{
                maxHeight = height[index2]
        }</span> else<span class="cov8" title="1"> {
                maxHeight = height[index1]
        }</span>
        <span class="cov8" title="1">count := 0
        for i := index1; i &lt; index2; i++ </span><span class="cov8" title="1">{
                if maxHeight &gt;= height[i] </span><span class="cov8" title="1">{
                        count += maxHeight - height[i]
                }</span>
        }

        <span class="cov8" title="1">return count</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package pathsumiii

type TreeNode struct {
        Val   int
        Left  *TreeNode
        Right *TreeNode
}

func pathSum(root *TreeNode, targetSum int) int <span class="cov8" title="1">{
        return findPath(root, &amp;[]*TreeNode{}, targetSum)
}</span>

func findPath(node *TreeNode, path *[]*TreeNode, target int) int <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">ans := 0
        *path = append(*path, node)
        ans += findPath(node.Left, path, target)
        ans += findPath(node.Right, path, target)

        sum := 0
        for i := len(*path) - 1; i &gt; -1; i-- </span><span class="cov8" title="1">{
                sum += (*path)[i].Val
                if sum == target </span><span class="cov8" title="1">{
                        ans += 1
                }</span>
        }

        <span class="cov8" title="1">*path = (*path)[:len(*path)-1]

        return ans</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package findanagrams

func findAnagrams(s string, p string) []int <span class="cov8" title="1">{
        lenS := len(s)
        lenP := len(p)
        arr := []int{}
        for i := 0; i &lt;= lenS-lenP; i++ </span><span class="cov8" title="1">{
                if arePermutation(s[i:i+lenP], p, lenP) </span><span class="cov8" title="1">{
                        arr = append(arr, i)
                }</span>
        }

        <span class="cov8" title="1">return arr</span>
}

func arePermutation(s1 string, s2 string, lenS int) bool <span class="cov8" title="1">{
        var a [26]int
        for i := 0; i &lt; lenS; i++ </span><span class="cov8" title="1">{
                a[int(s1[i])-'a']++
                a[int(s2[i])-'a']--
        }</span>
        <span class="cov8" title="1">for _, value := range a </span><span class="cov8" title="1">{
                if value != 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package permuteunique

func permuteUnique(nums []int) [][]int <span class="cov8" title="1">{
        return heapGenerate(len(nums), nums, [][]int{})
}</span>

func heapGenerate(k int, nums []int, ans [][]int) [][]int <span class="cov8" title="1">{
        if k == 1 </span><span class="cov8" title="1">{
                ans = merge(ans, nums)
        }</span> else<span class="cov8" title="1"> {
                ans = heapGenerate(k-1, nums, ans)
                for i := 0; i &lt; k-1; i++ </span><span class="cov8" title="1">{
                        if k%2 == 0 </span><span class="cov8" title="1">{
                                temp := nums[k-1]
                                nums[k-1] = nums[i]
                                nums[i] = temp
                        }</span> else<span class="cov8" title="1"> {
                                temp := nums[k-1]
                                nums[k-1] = nums[0]
                                nums[0] = temp
                        }</span>
                        <span class="cov8" title="1">ans = heapGenerate(k-1, nums, ans)</span>
                }
        }

        <span class="cov8" title="1">return ans</span>
}

func merge(ans [][]int, current []int) [][]int <span class="cov8" title="1">{
        for _, each := range ans </span><span class="cov8" title="1">{
                if equal(each, current) </span><span class="cov8" title="1">{
                        return ans
                }</span>
        }
        <span class="cov8" title="1">tmp := make([]int, len(current))
        copy(tmp, current)
        return append(ans, tmp)</span>
}

func equal(a, b []int) bool <span class="cov8" title="1">{
        if len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i, v := range a </span><span class="cov8" title="1">{
                if v != b[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package relativeranks

import (
        "container/heap"
        "fmt"
)

type MaxHeap []int

func (h MaxHeap) Len() int           <span class="cov8" title="1">{ return len(h) }</span>
func (h MaxHeap) Less(i, j int) bool <span class="cov8" title="1">{ return h[i] &gt; h[j] }</span>
func (h MaxHeap) Swap(i, j int)      <span class="cov8" title="1">{ h[i], h[j] = h[j], h[i] }</span>
func (h *MaxHeap) Push(x interface{}) <span class="cov8" title="1">{
        *h = append(*h, x.(int))
}</span>
func (h *MaxHeap) Pop() interface{} <span class="cov8" title="1">{
        old := *h
        n := len(old)
        x := old[n-1]
        *h = old[0 : n-1]
        return x
}</span>

func findRelativeRanks(score []int) []string <span class="cov8" title="1">{
        max := &amp;MaxHeap{}
        heap.Init(max)
        for _, each := range score </span><span class="cov8" title="1">{
                heap.Push(max, each)
        }</span>
        <span class="cov8" title="1">m := make(map[int]string)
        i := 1
        for len(*max) != 0 </span><span class="cov8" title="1">{
                val := heap.Pop(max)
                m[val.(int)] = toString(i)
                i++
        }</span>
        <span class="cov8" title="1">ans := []string{}
        for _, each := range score </span><span class="cov8" title="1">{
                ans = append(ans, m[each])
        }</span>
        <span class="cov8" title="1">return ans</span>
}

func toString(in int) string <span class="cov8" title="1">{
        if in == 1 </span><span class="cov8" title="1">{
                return "Gold Medal"
        }</span> else<span class="cov8" title="1"> if in == 2 </span><span class="cov8" title="1">{
                return "Silver Medal"
        }</span> else<span class="cov8" title="1"> if in == 3 </span><span class="cov8" title="1">{
                return "Bronze Medal"
        }</span>
        <span class="cov8" title="1">return fmt.Sprint(in)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package complexnumbermultiplication

import (
        "fmt"
        "regexp"
        "strconv"
)

type complex struct {
        real int
        img  int
}

func (c complex) Multiply(c2 complex) complex <span class="cov8" title="1">{
        return complex{real: (c.real*c2.real - c.img*c2.img), img: (c.real*c2.img + c.img*c2.real)}
}</span>

func (c complex) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%d+%di", c.real, c.img)
}</span>

func complexNumberMultiply(num1 string, num2 string) string <span class="cov8" title="1">{
        com1 := createComplex(num1)
        com2 := createComplex(num2)
        return com1.Multiply(com2).String()
}</span>

func createComplex(str string) complex <span class="cov8" title="1">{
        r, _ := regexp.Compile(`(\-?)([0-9]+)\+(\-?)([0-9]+)i`)
        matches := r.FindStringSubmatch(str)
        real, _ := strconv.Atoi(matches[2])
        img, _ := strconv.Atoi(matches[4])
        if matches[1] == "-" </span><span class="cov8" title="1">{
                real = real * -1
        }</span>
        <span class="cov8" title="1">if matches[3] == "-" </span><span class="cov8" title="1">{
                img = img * -1
        }</span>
        <span class="cov8" title="1">return complex{real: real, img: img}</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package permutationinstring

func checkInclusion(s1 string, s2 string) bool <span class="cov8" title="1">{
        lenS1 := len(s1)
        lenS2 := len(s2)
        for i := 0; i &lt;= lenS2-lenS1; i++ </span><span class="cov8" title="1">{
                if arePermutation(s2[i:i+lenS1], s1, lenS1) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func arePermutation(s1 string, s2 string, lenS int) bool <span class="cov8" title="1">{
        var a [26]int
        for i := 0; i &lt; lenS; i++ </span><span class="cov8" title="1">{
                a[int(s1[i])-'a']++
                a[int(s2[i])-'a']--
        }</span>
        <span class="cov8" title="1">for _, value := range a </span><span class="cov8" title="1">{
                if value != 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package getpermutation

import "fmt"

func getPermutation(n int, k int) string <span class="cov8" title="1">{
        nums := []int{}
        for i := 1; i &lt;= n; i++ </span><span class="cov8" title="1">{
                nums = append(nums, i)
        }</span>
        <span class="cov8" title="1">for i := 1; i &lt; k; i++ </span><span class="cov8" title="1">{
                nextPermutation(nums)
        }</span>
        <span class="cov8" title="1">return join(nums)</span>
}

func join(nums []int) string <span class="cov8" title="1">{
        s := ""
        for _, char := range nums </span><span class="cov8" title="1">{
                s = fmt.Sprintf("%s%d", s, char)
        }</span>
        <span class="cov8" title="1">return s</span>
}

func nextPermutation(nums []int) <span class="cov8" title="1">{
        n := len(nums)
        k := -1
        for x := 0; x &lt; n-1; x++ </span><span class="cov8" title="1">{
                if nums[x] &lt; nums[x+1] </span><span class="cov8" title="1">{
                        if x &gt; k </span><span class="cov8" title="1">{
                                k = x
                        }</span>
                }
        }
        <span class="cov8" title="1">if k &gt; -1 </span><span class="cov8" title="1">{
                i := -1
                for x := 0; x &lt; n; x++ </span><span class="cov8" title="1">{
                        if nums[k] &lt; nums[x] </span><span class="cov8" title="1">{
                                if x &gt; i </span><span class="cov8" title="1">{
                                        i = x
                                }</span>
                        }
                }
                <span class="cov8" title="1">swap(nums, k, i)
                reverse(nums[k+1:])</span>
        } else<span class="cov0" title="0"> {
                reverse(nums)
        }</span>
}

func reverse(nums []int) <span class="cov8" title="1">{
        n := len(nums)
        for x := 0; x &lt; n/2; x++ </span><span class="cov8" title="1">{
                swap(nums, x, n-x-1)
        }</span>
}

func swap(nums []int, i, j int) <span class="cov8" title="1">{
        temp := nums[i]
        nums[i] = nums[j]
        nums[j] = temp
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package kthlargest

import (
        "container/heap"
)

type MinHeap []int
type MaxHeap []int

func (h MinHeap) Len() int           <span class="cov8" title="1">{ return len(h) }</span>
func (h MaxHeap) Len() int           <span class="cov8" title="1">{ return len(h) }</span>
func (h MinHeap) Less(i, j int) bool <span class="cov8" title="1">{ return h[i] &lt; h[j] }</span>
func (h MaxHeap) Less(i, j int) bool <span class="cov8" title="1">{ return h[i] &gt; h[j] }</span>
func (h MinHeap) Swap(i, j int)      <span class="cov8" title="1">{ h[i], h[j] = h[j], h[i] }</span>
func (h MaxHeap) Swap(i, j int)      <span class="cov8" title="1">{ h[i], h[j] = h[j], h[i] }</span>

func (h *MinHeap) Push(x interface{}) <span class="cov8" title="1">{
        *h = append(*h, x.(int))
}</span>
func (h *MaxHeap) Push(x interface{}) <span class="cov8" title="1">{
        *h = append(*h, x.(int))
}</span>

func (h *MinHeap) Pop() interface{} <span class="cov8" title="1">{
        old := *h
        n := len(old)
        x := old[n-1]
        *h = old[0 : n-1]
        return x
}</span>
func (h *MaxHeap) Pop() interface{} <span class="cov8" title="1">{
        old := *h
        n := len(old)
        x := old[n-1]
        *h = old[0 : n-1]
        return x
}</span>

type KthLargest struct {
        MaxHeap MaxHeap
        MinHeap MinHeap
        k       int
}

func Constructor(k int, nums []int) KthLargest <span class="cov8" title="1">{
        max := &amp;MaxHeap{}
        min := &amp;MinHeap{}
        heap.Init(max)
        heap.Init(min)
        for _, each := range nums </span><span class="cov8" title="1">{
                heap.Push(max, each)
        }</span>

        <span class="cov8" title="1">i := 0
        for i &lt; k &amp;&amp; len(*max) != 0 </span><span class="cov8" title="1">{
                heap.Push(min, heap.Pop(max))
                i++
        }</span>
        <span class="cov8" title="1">return KthLargest{MaxHeap: *max, MinHeap: *min, k: k}</span>
}

func (k *KthLargest) Add(val int) int <span class="cov8" title="1">{
        if len(k.MinHeap) == 0 || val &gt; k.MinHeap[0] </span><span class="cov8" title="1">{
                heap.Push(&amp;k.MinHeap, val)
        }</span> else<span class="cov8" title="1"> {
                heap.Push(&amp;k.MaxHeap, val)
        }</span>
        <span class="cov8" title="1">for len(k.MinHeap) &lt; k.k &amp;&amp; len(k.MaxHeap) != 0 </span><span class="cov0" title="0">{
                heap.Push(&amp;k.MinHeap, heap.Pop(&amp;k.MaxHeap))
        }</span>
        <span class="cov8" title="1">if len(k.MinHeap) &gt; k.k </span><span class="cov8" title="1">{
                heap.Push(&amp;k.MaxHeap, heap.Pop(&amp;k.MinHeap))
        }</span>
        <span class="cov8" title="1">return k.MinHeap[0]</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package search

func search(nums []int, target int) int <span class="cov8" title="1">{
        return binarySearch(nums, 0, len(nums)/2, len(nums), target)
}</span>

func binarySearch(nums []int, low, middle, high, target int) int <span class="cov8" title="1">{
        if nums[middle] == target </span><span class="cov8" title="1">{
                return middle
        }</span>
        <span class="cov8" title="1">if low == middle || middle == high </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">if nums[middle] &gt; target </span><span class="cov8" title="1">{
                return binarySearch(nums, low, (low+middle)/2, middle, target)
        }</span> else<span class="cov8" title="1"> {
                return binarySearch(nums, middle, (high+middle)/2, high, target)
        }</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package deleteandearn

func deleteAndEarn(nums []int) int <span class="cov8" title="1">{
        var hash = make(map[int]int)
        var memo [100000]int
        maxValue := -1
        for _, num := range nums </span><span class="cov8" title="1">{
                if num &gt; maxValue </span><span class="cov8" title="1">{
                        maxValue = num
                }</span>
                <span class="cov8" title="1">_, ok := hash[num]
                if ok </span><span class="cov8" title="1">{
                        hash[num] += 1
                }</span> else<span class="cov8" title="1"> {
                        hash[num] = 1
                }</span>
        }
        <span class="cov8" title="1">for i := 1; i &lt;= maxValue; i++ </span><span class="cov8" title="1">{
                dp(&amp;memo, hash, i)
        }</span>

        <span class="cov8" title="1">return memo[maxValue]</span>
}

func max(a int, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func dp(memo *[100000]int, hash map[int]int, n int) int <span class="cov8" title="1">{
        if n == 1 </span><span class="cov8" title="1">{
                memo[n] = n * hash[n]
        }</span> else<span class="cov8" title="1"> {
                memo[n] = max(n*hash[n]+memo[n-2], memo[n-1])
        }</span>

        <span class="cov8" title="1">return memo[n]</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package minimumwindowsubstring

func minWindow(s string, t string) string <span class="cov0" title="0">{
        return ""
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package combinations

func combine(n int, k int) [][]int <span class="cov8" title="1">{
        ans := [][]int{}
        for i := 1; i &lt;= n; i++ </span><span class="cov8" title="1">{
                ans = combineRecur([]int{i}, ans, n, k)
        }</span>
        <span class="cov8" title="1">return ans</span>
}

func combineRecur(arr []int, answer [][]int, n, k int) [][]int <span class="cov8" title="1">{
        if len(arr) == k </span><span class="cov8" title="1">{
                answer = append(answer, arr)
        }</span> else<span class="cov8" title="1"> {
                for i := arr[len(arr)-1] + 1; i &lt;= n; i++ </span><span class="cov8" title="1">{
                        newArr := getCopy(arr)
                        answer = combineRecur(append(newArr, i), answer, n, k)
                }</span>
        }
        <span class="cov8" title="1">return answer</span>
}

func getCopy(src []int) []int <span class="cov8" title="1">{
        dst := make([]int, len(src))
        copy(dst, src)
        return dst
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package isgraphbipartite

func isBipartite(graph [][]int) bool <span class="cov8" title="1">{
        visited := map[int]bool{}
        for i := 0; i &lt; len(graph); i++ </span><span class="cov8" title="1">{
                dfs(i, graph, visited, true)
        }</span>
        <span class="cov8" title="1">for v, adjs := range graph </span><span class="cov8" title="1">{
                for _, adj := range adjs </span><span class="cov8" title="1">{
                        if visited[v] == visited[adj] </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

func dfs(v int, graph [][]int, visited map[int]bool, shouldGoToSetA bool) <span class="cov8" title="1">{
        _, isVisted := visited[v]
        if !isVisted </span><span class="cov8" title="1">{
                visited[v] = shouldGoToSetA
        }</span>
        <span class="cov8" title="1">for _, adj := range graph[v] </span><span class="cov8" title="1">{
                _, isVisted := visited[adj]
                if !isVisted </span><span class="cov8" title="1">{
                        dfs(adj, graph, visited, !shouldGoToSetA)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package distancek

type TreeNode struct {
        Val   int
        Left  *TreeNode
        Right *TreeNode
}

func distanceK(root *TreeNode, target *TreeNode, k int) []int <span class="cov8" title="1">{
        ans, _ := findKdistance(root, target, k, []int{})
        return ans
}</span>

func findKdistance(root *TreeNode, target *TreeNode, k int, ans []int) ([]int, int) <span class="cov8" title="1">{
        if root == nil </span><span class="cov8" title="1">{
                return ans, -1
        }</span>

        <span class="cov8" title="1">if root.Val == target.Val </span><span class="cov8" title="1">{
                ans = findKdistanceNodesDown(root, k, ans)
                return ans, 0
        }</span>

        <span class="cov8" title="1">ans, dl := findKdistance(root.Left, target, k, ans)
        if dl != -1 </span><span class="cov8" title="1">{
                if dl+1 == k </span><span class="cov0" title="0">{
                        ans = append(ans, root.Val)
                }</span> else<span class="cov8" title="1"> {
                        ans = findKdistanceNodesDown(root.Right, k-dl-2, ans)
                }</span>
                <span class="cov8" title="1">return ans, dl + 1</span>
        }

        <span class="cov8" title="1">ans, dr := findKdistance(root.Right, target, k, ans)
        if dr != -1 </span><span class="cov8" title="1">{
                if dr+1 == k </span><span class="cov0" title="0">{
                        ans = append(ans, root.Val)
                }</span> else<span class="cov8" title="1"> {
                        ans = findKdistanceNodesDown(root.Left, k-dr-2, ans)
                }</span>
                <span class="cov8" title="1">return ans, dr + 1</span>
        }

        <span class="cov8" title="1">return ans, -1</span>
}

func findKdistanceNodesDown(node *TreeNode, k int, ans []int) []int <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return ans
        }</span>
        <span class="cov8" title="1">if k == 0 </span><span class="cov8" title="1">{
                ans = append(ans, node.Val)
        }</span>
        <span class="cov8" title="1">ans = findKdistanceNodesDown(node.Left, k-1, ans)
        ans = findKdistanceNodesDown(node.Right, k-1, ans)
        return ans</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package findthetownjudge

func findJudge(n int, trust [][]int) int <span class="cov8" title="1">{
        var adjMatrix [1001][1001]int

        for _, v := range trust </span><span class="cov8" title="1">{
                adjMatrix[v[0]][v[1]] = 1
        }</span>

        <span class="cov8" title="1">for i := 1; i &lt;= n; i++ </span><span class="cov8" title="1">{
                sumX := 0
                for _, v := range adjMatrix[i] </span><span class="cov8" title="1">{
                        sumX += v
                }</span>
                <span class="cov8" title="1">if sumX == 0 </span><span class="cov8" title="1">{
                        sumY := 0
                        for j := 1; j &lt;= n; j++ </span><span class="cov8" title="1">{
                                sumY += adjMatrix[j][i]
                        }</span>
                        <span class="cov8" title="1">if sumY == n-1 </span><span class="cov8" title="1">{
                                return i
                        }</span>
                }
        }
        <span class="cov8" title="1">return -1</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
